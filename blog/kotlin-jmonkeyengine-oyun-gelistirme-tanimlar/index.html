<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="robots" content="index, follow">
<title>Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</title>

<meta name="author" content="Eray Aydın">
<meta name="description" content="Scala Developer, Laravel Artisan, Free Software Fan, Archy, Linux Lover, WoW Loremaster, Junior Game Developer">
<link rel="canonical" href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/">
<link rel="shortcut icon" type="image/x-icon" href="https://era.yayd.in/favicon.png">

<meta property="og:type" content="website">
<meta property="og:url" content="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/">
<meta property="og:site_name" content="Eray Aydın">
<meta property="og:title" content="Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar">
<meta property="og:description" content="Scala Developer, Laravel Artisan, Free Software Fan, Archy, Linux Lover, WoW Loremaster, Junior Game Developer">





<link rel="alternate" type="application/atom+xml" title="RSS" href="https://era.yayd.in/atom.xml"> 



<link rel="stylesheet" type="text/css" href="https://era.yayd.in/app.css"/>
<style></style>


</head>
<body>
      <header>
          <nav>
    
      <a href="/">
        &#x2F;home
      </a>
    
      <a href="/about/">
        &#x2F;about
      </a>
    
      <a href="/journal/">
        &#x2F;journal
      </a>
    
      <a href="/blog/" class="active">
        &#x2F;blog
      </a>
    
      <a href="https://github.com/erayaydin/erayaydin.github.io">
        &#x2F;download
      </a>
    
    <div>
      <input type="checkbox" id="themeToggle" style="display: none;">
      <label for="themeToggle"><svg id="themeIcon" class="icons"><use href="https://era.yayd.in/icons.svg#lightMode"></use></svg></label>
      <audio id="themeSound">
        <source src="https://era.yayd.in/click.ogg" type="audio/ogg">
      </audio>
    </div>
</nav>

      </header>
      <main>
          
<div>
    <a href="..">..</a>/<span class="accent-data">kotlin-jmonkeyengine-oyun-gelistirme-tanimlar</span>
</div>
<time datetime="2020-03-22T05:01:53">Published on: <span class="accent-data">2020-03-22T05:01:53</span></time>
<address rel="author">By <span class="accent-data">Eray Aydın</span></address>
<h1>Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</h1>
<hr>
<h2 id="toc">Table of contents</h2>
<ul>
  
  <li>
    <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar">Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</a>
    
    <ul>
      
      <li>
        <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#kotlin-nedir">Kotlin Nedir?</a>
        <ul>
          
        </ul>
      </li>
      
      <li>
        <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#jmonkeyengine-nedir">jMonkeyEngine Nedir?</a>
        <ul>
          
          <li>
            <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#jmonkeyengine-3-sdk-jmonkeyplatform">jMonkeyEngine 3 SDK (jMonkeyPlatform)</a>
          </li>
          
          <li>
            <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#lwjgl-lightweight-java-game-library">LWJGL (Lightweight Java Game Library)</a>
          </li>
          
          <li>
            <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#bullet-physics">Bullet Physics</a>
          </li>
          
          <li>
            <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#nifty-gui">Nifty GUI</a>
          </li>
          
        </ul>
      </li>
      
      <li>
        <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#gradle">Gradle</a>
        <ul>
          
        </ul>
      </li>
      
      <li>
        <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#graphic-pipeline">Graphic Pipeline</a>
        <ul>
          
          <li>
            <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#genel-yapi">Genel Yapı</a>
          </li>
          
        </ul>
      </li>
      
      <li>
        <a href="https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#scene-graph">Scene Graph</a>
        <ul>
          
        </ul>
      </li>
      
    </ul>
    
  </li>
  
</ul>
<hr>
<div class="page-content">
<h1 id="kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar"><a class="no-style" href="#kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar" aria-label="Anchor link for: kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar">#</a>
Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</h1>
<p>Merhaba,
Bu yazı serisi içerisinde <strong>Kotlin</strong> ve <strong>jMonkeyEngine</strong> ile oyun geliştirme yöntemine bakacağız. Seri içerisinde sorunuz olursa sormaktan çekinmeyin. Sorularınızı issue olarak Github üzerinden açabilirsiniz.</p>
<blockquote>
<p>Not: <strong>Kotlin</strong> tecrübem hiç denecek kadar azdır, bu sebeple hata yaptığım noktalar olursa şimdiden özür dilerim. Hataları Git reposunda düzelterek PR oluşturabilirsiniz :)</p>
</blockquote>
<p>Şimdi <strong>kısaca</strong> jMonkeyEngine, Kotlin, Gradle, Graphic Pipeline ve Scene Graph kavramlarına bakacağız.</p>
<h2 id="kotlin-nedir"><a class="no-style" href="#kotlin-nedir" aria-label="Anchor link for: kotlin-nedir">##</a>
Kotlin Nedir?</h2>
<p>Kotlin; statik, nesneye yönelimli özgür bir fonksiyonel programlama dilidir. Java ile birlikte çalışacak şekilde geliştirilmiştir lakin çok daha “hoş” bir syntax yapısı ile geliştirme yapmanıza olanak sağlamakta. Konsept olarak JVM için kullanılmakta olsa da artık LLVM ile mobil native ve JS için de geliştirmede kullanılmakta. Birden çok platformu desteklemesine rağmen jMonkeyEngine ile oyun geliştirirken bu seride Kotlin JVM’i kullanarak ilerleyeceğiz bu sebeple Kotlin ile gelen cross-platform özelliğini kullanmayacağız. JVM ile çalıştırdığımız için JVM’in cross-platform özelliği seri içerisinde devam etmekte.</p>
<p>Yararlanabileceğiniz kaynaklar:</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://kotlinlang.org/">Kotlin Website</a></li>
<li><a rel="noopener" target="_blank" href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/introduction.html">Python tecrübesi olanlar için resmi Kotlin dersleri</a></li>
<li><a rel="noopener" target="_blank" href="https://medium.com/@halilozel1903/kotlin-nedir-43e312d2dca6">Halil Özel’den Kotlin Nedir?</a></li>
<li><a rel="noopener" target="_blank" href="https://www.mobilhanem.com/kotlin-egitimleri/">Mobil Hanem - Kotlin Eğitimi</a></li>
</ul>
<h2 id="jmonkeyengine-nedir"><a class="no-style" href="#jmonkeyengine-nedir" aria-label="Anchor link for: jmonkeyengine-nedir">##</a>
jMonkeyEngine Nedir?</h2>
<p>jMonkeyEngine, Java ile yazılmış bir modern 3D geliştirme sağlayan bir oyun motorudur. Varsayılan olarak <em>LWJGL(Lightweight Java Game Library)</em> renderer paketini kullanmaktadır. Elbetteki kendi renderer paketinizi veya birbaşka 3. parti renderer paketini de kolayca enjekte edebilirsiniz. <em>LWJGL</em> ile OpenGL2+ sürümleri desteklenmektedir. Bu da oldukça geniş bir yelpaze demek. Alt başlıklar halinde; <em>jMonkeyEngineSDK</em>,  <em>LWJGL</em>, <em>Bullet Physics</em>, <em>NiftyGUI</em> parçalarını inceleyeceğiz.</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://github.com/jMonkeyEngine/jmonkeyengine/releases">jMonkeyEngine sürümleri ve indirme</a> (İndirme yapmanıza gerek yok, jMonkeyEngine 3 SDK ile devam edecekseniz zaten kurulu gelecektir. Bir sonraki yazıda Gradle ile inşa mekanizmasını hazırlarken de jMonkeyEngine paketini indirteceğiz.)</li>
</ul>
<p>Yararlanabileceğiniz kaynaklar:</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://jmonkeyengine.org/">jMonkeyEngine Website</a></li>
<li><a rel="noopener" target="_blank" href="https://wiki.jmonkeyengine.org/">jMonkeyEngine Wiki</a></li>
<li><a rel="noopener" target="_blank" href="https://javadoc.jmonkeyengine.org/v3.x/index.html">JavaDoc</a></li>
<li><a rel="noopener" target="_blank" href="https://hub.jmonkeyengine.org/">Forum</a></li>
</ul>
<h3 id="jmonkeyengine-3-sdk-jmonkeyplatform"><a class="no-style" href="#jmonkeyengine-3-sdk-jmonkeyplatform" aria-label="Anchor link for: jmonkeyengine-3-sdk-jmonkeyplatform">###</a>
jMonkeyEngine 3 SDK (jMonkeyPlatform)</h3>
<p>jMonkeyEngine 3 sürümü ile gelen <code>jMonkeyEngine 3 SDK</code>, Netbeans tabanlı olan bu geliştirme ortamı eklenti desteği ve grafiksel geliştirme sağlamaktadır. İçerisinde, Sahne Editörü (Scene Editor), Materyal Editörü (Material Editor), Filtreleme Editörü (Filter Editor), dahili Blender ve dahili JDK bulunmaktadır.</p>
<p>Seri içerisinde olabildiğince <code>Intellij IDEA</code> ve <code>jMonkeyEngine 3 SDK</code> için anlatım yapmaya çalışacağım lakin sorun oluşturabilecek noktalarda <code>Intellij IDEA</code> üzerinden geliştirmeye devam edeceğim. Bu seri içerisindeki anlatımları bu IDE’lerden birinden veya beğendiğiniz başka bir IDE veya metin editörü ile uygulayabilirsiniz.</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://github.com/jMonkeyEngine/sdk/releases/">SDK Versiyonları ve İndirme (GNU/Linux, Windows, OSX ve Kaynak</a></li>
</ul>
<h3 id="lwjgl-lightweight-java-game-library"><a class="no-style" href="#lwjgl-lightweight-java-game-library" aria-label="Anchor link for: lwjgl-lightweight-java-game-library">###</a>
LWJGL (Lightweight Java Game Library)</h3>
<p>LWJGL, Java ile yazılmış bir oyun kütüphanesidir. Cross-platform olarak grafik (OpenGL, Vulkan), ses(OpenAL) ve paralel hesaplama(OpenCL) uygulamaları geliştirmenize yardımcı olmaktadır.</p>
<p>Dilerseniz geliştirmenizi LWJGL ve 3. parti yardımcı olacak paketlerle (GUI, Physic paketleri, Networking paketleri vs) yaparak daha low-level devam edebilirsiniz. Bu seri içerisindeki anlatımlar jMonkeyEngine odaklı olacağı için pek faydası olmayacaktır lakin göz atıp fikir almak da faydalı olur elbette :)</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://www.lwjgl.org/">Website</a></li>
<li><a rel="noopener" target="_blank" href="https://www.lwjgl.org/guide">Guide</a></li>
<li><a rel="noopener" target="_blank" href="https://github.com/LWJGL/lwjgl3/tree/master/modules/samples/src/test/java/org/lwjgl/demo">Örnekler</a></li>
</ul>
<h3 id="bullet-physics"><a class="no-style" href="#bullet-physics" aria-label="Anchor link for: bullet-physics">###</a>
Bullet Physics</h3>
<p>Bullet, C&amp;C++ ile geliştirilmiş bir fizik motorudur. Çarpışma hesaplama (collision detection), hareket ve diğer fizik işlemlerini sağlayan bir pakettir.</p>
<p>jMonkeyEngine, jBullet (Bullet’in Java’ya göre yazılmış hali) kullanarak fizik mekaniği sağlamaktadır.</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://github.com/bulletphysics/bullet3">Bullet Physics SDK</a></li>
<li><a rel="noopener" target="_blank" href="http://jbullet.advel.cz/">jBullet</a></li>
</ul>
<h3 id="nifty-gui"><a class="no-style" href="#nifty-gui" aria-label="Anchor link for: nifty-gui">###</a>
Nifty GUI</h3>
<p>Nifty GUI, Java ile yazılmış bir GUI geliştirme paketidir. Çizim kısmında OpenGL kullanmaktadır lakin elbette bu render kısmına müdahale edip başka bir renderer wrapper yazarak injekte edebilirsiniz.</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://github.com/nifty-gui/nifty-gui">Git Depo</a></li>
</ul>
<h2 id="gradle"><a class="no-style" href="#gradle" aria-label="Anchor link for: gradle">##</a>
Gradle</h2>
<p>Java, Groovy ve Kotlin ile yazılmış bir build mekanizmasıdır. Maven’deki gibi XML yazım biçimi yerine Groovy tarzında build otomasyonu oluşturmanızı sağlar. Paketlerimizi Gradle ile belirleyip, inşa mekanizmasını kullanacağız.</p>
<ul>
<li><a rel="noopener" target="_blank" href="https://gradle.org/">Website</a></li>
<li><a rel="noopener" target="_blank" href="https://github.com/gradle/gradle">Git Depo</a></li>
</ul>
<h2 id="graphic-pipeline"><a class="no-style" href="#graphic-pipeline" aria-label="Anchor link for: graphic-pipeline">##</a>
Graphic Pipeline</h2>
<p>3 Boyutlu bir ortamın, 2 boyutlu ekrana getirilmesindeki süreci özetleyen kavrama “Graphic Pipeline” denmektedir. Oyunumuzu 3 boyutlu ortamda geliştireceğimiz için, grafiğin hazırlanma süreci hakkında bilgi sahibi olmak da önemlidir. Özellikle daha düşük seviyeli ortamlarda (LWJGL veya direk bir grafik API kullanarak) geliştirme yapanların muhakkak bilgi sahibi olması gereken bir kavramdır. Hem yazılımsal hem de donanımsal bir süreç gerektiren bu yolculuk için herkes tarafından benimsenmiş bir yol bulunmamaktadır. Lakin, Direct3D ve OpenGL gibi grafik kütüphaneleri, donanım hızlandırması sağlamak amaçlı bu süreçlerdeki benzer adımları ortaklaştırmıştır. Yani, geliştiricinin grafik hızlandırmayı kullanması için donanıma direk müdahalesi yerine bunu soyutlayarak kullanmasını amaçlamaktadır.</p>
<p>Bu konuda, şu videoyu izlemenizi tavsiye ederim: <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=bgckX62f4EA">thebennybox - Intro to Modern OpenGL Tutorial: Graphics Pipeline</a></p>
<h3 id="genel-yapi"><a class="no-style" href="#genel-yapi" aria-label="Anchor link for: genel-yapi">###</a>
Genel Yapı</h3>
<p>Genel yapıda çizimin oluşması ve ekrana gelmesi için 3 adım bulunmaktadır:</p>
<ol>
<li>Application (Uygulama)</li>
<li>Geometry (Geometri)</li>
<li>Rasterization (Pikselleştirme)</li>
</ol>
<h4 id="1-application-uygulama"><a class="no-style" href="#1-application-uygulama" aria-label="Anchor link for: 1-application-uygulama">####</a>
1. Application (Uygulama)</h4>
<p>Uygulama tarafından hesaplanan çizimin (bütün collision hesaplaması, çizilecek nesnelerin noktası, üçgenleri vs) belirlenip pipeline’da bir sonraki adıma iletilmesidir.</p>
<h4 id="2-geometry-geometri"><a class="no-style" href="#2-geometry-geometri" aria-label="Anchor link for: 2-geometry-geometri">####</a>
2. Geometry (Geometri)</h4>
<p>Geometri adımında, Model &amp; Camera’nin yerleştirilmesi, ışıklandırmanın hesaplanması, projeksiyonun hesaplanması, clipping (uzak/yakın) ve pencereye göre konumlandırılması adımları yer almaktadır.</p>
<h4 id="3-rasterization-piksellestirme"><a class="no-style" href="#3-rasterization-piksellestirme" aria-label="Anchor link for: 3-rasterization-piksellestirme">####</a>
3. Rasterization (Pikselleştirme)</h4>
<p>Piksel içerisindeki rengi belirleyen adımdır. Çizilecek nesnenin her bir noktası için bu pikselleştirme yapılmaktadır (eğer varsa; Fragment Shader bu adım içerisinde devreye alınmaktadır).</p>
<h4 id="opengl-rendering-pipeline"><a class="no-style" href="#opengl-rendering-pipeline" aria-label="Anchor link for: opengl-rendering-pipeline">####</a>
OpenGL Rendering Pipeline</h4>
<p>Örnek olarak, OpenGL’in Rendering Pipeline’ı açıklamak gerekirse;</p>
<ol>
<li>Vertex Spec (OpenGL)</li>
<li>Vertex Shader (Programcı tarafından müdahale edilebilir)</li>
<li>Tessellation (Opsiyonel olarak, programcı tarafından müdahale edilebilir)</li>
<li>Geometry Shader (Opsiyonel olarak, programcı tarafından müdahale edilebilir)</li>
<li>Vertex Post-Processing (OpenGL)</li>
<li>Primitive Assembly (OpenGL)</li>
<li>Rasterization (OpenGL)</li>
<li>Fragment Shader (Opsiyonel olarak, programcı tarafından müdahale edilebilir)</li>
<li>Per-Sample Ops (OpenGL)</li>
</ol>
<p>Burada programcının çizimin donanımsal hızlandırma kullanması için müdahale etmesini sağlamaktadır. Vertex Shader, Geometry Shader ve Fragment Shader’ı GLSL dili ile yazarak donanıma yapması gereken işlevi söyleme işidir.</p>
<blockquote>
<p>Bu konuda, şu videoyu izlemenizi tavsiye ederim: <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=bgckX62f4EA">thebennybox - Intro to Modern OpenGL Tutorial: Graphics Pipeline</a></p>
</blockquote>
<h2 id="scene-graph"><a class="no-style" href="#scene-graph" aria-label="Anchor link for: scene-graph">##</a>
Scene Graph</h2>
<p>jMonkeyEngine ile oyun geliştirirken bu kavramı sıkça duyacağız.  Oyunumuzu geliştirirken kurguladığımız sanal ortama <strong>scene graph</strong> denmektedir. Bu sanal sahnemizdeki her bir objemize de <strong>Spatial</strong> diyeceğiz. Bu <em>spatial</em> nesnelerimizin her birinde de <strong>translation</strong>(konum), <strong>rotation</strong>(baktığı yön) ve <strong>scale</strong>(büyüklük) bilgisi bulunacaktır. Buradaki <strong>translation</strong> konum, 3 boyuttan aşina olduğumuz X,Y ve Z kavramları ile belirtilmektedir.</p>
<p>Bu sahnemizi kurgularken farklı obje türüne ihtiyacımız olacaktır. Tahmin edebileceğiniz gibi, sahnemiz içerisinde görünmesini istediğimiz objeler olacağı gibi görünmesini istemediğimiz ve konum/baktığı yön/büyüklük gibi değerlerini kullanacağımız objeler de yer alacaktır. Varsayılan olarak oluşturduğumuz bi <strong>spatial</strong> nesneler görünmez durumdadır ve sadece bu bahsettiğim bilgileri tutmaktadır. Lakin <strong>Geometry</strong> türünde olan <strong>spatial</strong> nesneler ise, şekli olan ve görülebilir nesnelerdir. Şekillerini <strong>mesh</strong> ler belirtmekte ve <strong>material</strong> ler ile de görüntüsünü almaktadır.</p>
<p>Bir diğer husus da <strong>spatial</strong> nesnelerin yönetimi. Kurgu hazırladığımız için bir süre sonra bu nesnelerin yönetiminde zorlanabiliriz. Bu sebeple, <strong>node</strong> türündeki <strong>spatial</strong> ları kullanacağız. Hatırlarsanız, <strong>spatial</strong> ların belirli bir konumu oluyordu, diğer nesnelerimizi bu <strong>node</strong> lara yerleştireceğiz. <strong>node</strong> spatial’ları nested özelliğine sahip yani <strong>parent</strong> ve <strong>child</strong> node lar tanımlayabilirsiniz. Varsayılan olarak bu kurgumuzda <strong>base node</strong> üzerine diğer node ları ve spatial ları ekleyeceğiz.</p>
<p>Örnek vermek gerekirse;</p>
<ul>
<li>rootNode
<ul>
<li>playerNode
<ul>
<li>aimNode</li>
<li>armNode</li>
</ul>
</li>
<li>envNode
<ul>
<li>houseNode</li>
<li>marketNode</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Bu konuda hazırlanan şu slayt da oldukça bilgi verici: <a rel="noopener" target="_blank" href="https://wiki.jmonkeyengine.org/tutorials/scenegraph/assets/fallback/index.html">3D Scene Graph for Dummies</a></p>

</div>
<br>
<a href="https://github.com/erayaydin/zola-personal-blog/blob/main/content/blog&#x2F;2020-03-22-kotlin-jmonkeyengine-oyun-gelistirme-tanimlar.md" class="button">Contribute to this post</a>
<hr>
<script src="https://utteranc.es/client.js"
        repo="erayaydin/zola-personal-blog"
        issue-term="pathname"
        label="💬"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

      </main>
      <footer>
          <hr>
<div>
    <div>
        <p>Built with <a target="_blank" rel="noopener noreferrer" href="https://www.getzola.org">Zola</a>, theme inspired from <a target="_blank" rel="noopener noreferrer" href="https://github.com/Speyll/anemone">anemone</a>.</p>
    </div>

  <div>
    <a target="_blank" class="no-style" rel="noopener noreferrer" href="https://era.yayd.in/atom.xml" title="Subscribe via RSS for updates."><svg class="icons"><use href="https://era.yayd.in/icons.svg#rss"></use></svg></a>
  </div>

</div>

      </footer>
      
      <script src="https://era.yayd.in/app.js" defer></script>
      
</body>
</html>
